#Lab2 内存管理
## 简介
这个实验中，需要为操作系统写一份内存管理代码。内存管理有两个部分：  
第一个部分是内核的物理内存分配器，好让内核可以分配和释放内存。分配器将以4096字节为单位操作，即页。主要任务是维护一个记录了可用物理页和已分配物理页地址，每页被多少进程共享信息的数据结构。同样也要写分配和释放内存的方法。  
第二个部分为虚拟内存，即内核和用户程序使用的虚拟地址和物理地址的映射。当指令使用内存时，x86硬件内存管理单元（MMU)通过查询一套页表来实现这个映射。需要根据实验的具体要求来修改JOS设置MMU的页表。  
注意git checkout获取实验文件。
## Part a 物理页管理

操作系统必须保持追踪物理RAM里哪些部分是可用的，哪些是正在被使用的。JOS用页粒度来管理计算机物理内存，好让它能够使用MMU来映射和保护每一片分配内存。  
  
现在开始写物理页分配器。它使用一个链接的，struct PageInfo对象（不像xv6，这些对象并非嵌入在空闲页里）列表来保持追踪哪些页是可用的。每个struct PageInfo对应一个物理页。在实现其他虚拟内存功能前需要先写这个物理页分配器，因为页表管理代码需要分配物理内存来存储页表。  
  
> + Exercise 1
    在kern/pamp.c里，实现下列函数：
     boot_alloc()
     mem_init() (只需要满足调用 check_page_free_list(1))
     page_init()
     page_alloc()
     page_free() 

     check_page_free_list()和check_page_alloc()测试物理页分配器。需要启动JOS看看check_page_alloc()是否能成功输出。修改代码使其通过。添加assert()来核实代码是否正确会很有用。
  
boot_alloc(uint32_t n)是只在page_free_list表设置前，JOS设置虚拟内存系统时，使用的简单分配器，真正的分配器是page_alloc()。当n>0,分配n字节连续的物理内存，不初始化，返回一个内核虚拟地址。当n=0时，返回下一个还没有分配任何数据的空闲页。当内存耗尽时抛出panic异常。实现：  
```
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
   result = nextfree;
   nextfree = ROUNDUP(nextfree+n, PGSIZE);
	if((uint32_t) nextfree - KERNBASE > npages * PGSIZE)
		panic("Out of memory!\n");
   return result;
}
``` 
设置一个二级页表，kern_pgdir是它的线性（虚拟）地址根。  
meminit()设置了内核部分的地址空间（例如UTOP之上的地址）。
分配一个有n页'struct PageInfo'的数组pages，内核使用这个数组来保存对物理地址的追踪：在这个数组中，每个物理页都有与之相对应的struct PageInfo信息。用memset初始化所有信息为0。  

`	pages = (struct PageInfo*) boot_alloc(npages * sizeof(struct PageInfo));`  
`	memset(pages, 0, npages * sizeof(struct PageInfo));`  
  
pageinit()初始化页表，将可用的页标记为0，这样可以保留实模式下的IDT和BIOS结构，在需要时使用。基础内存的其他部分是可用的，[PGSIZE, npages_basemem * PGSIZE)内。然后是IO空洞，[IOPHYSMEM, EXTPHYSMEM)，这里不能被分配。扩展内存[EXTPHYSMEM, ...)，有的部分被使用了，有的是可用的。内核在物理内存的哪里？哪些页已经被页表和其他数据结构使用了？  
关于内存层次查阅memlayout.h  
```
void
page_init(void)
{
	size_t i;
	page_free_list = NULL;
	//num_extmem_alloc 扩展内存区占用的页数
	uint32_t num_extmem_alloc = ((uint32_t) boot_alloc(0) - KERNBASE) / PGSIZE;
	//num_iohole io空洞占用的页数
	uint32_t num_iohole = (EXTPHYSMEM - IOPHYSMEM) / PGSIZE;
	for (i = 0; i < npages; i++) {
		if (i == 0) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
			continue;
		}
		else if (i >= npages_basemem && i < npages_basemem + num_iohole + num_extmem_alloc) {
			pages[i].pp_ref = 1;
			pages[i].pp_link = NULL;
			continue;
		}
		else {
			pages[i].pp_ref = 0;
			pages[i].pp_link = page_free_list;
			page_free_list = &pages[i];
		}
	
	}
}
```
page_alloc(int alloc_flags)分配一个物理页，alloc_flags的ZERO置一，则返回整页的0。不要增加页的引用次数，只有在调用时才有必要这么做，不论是显式地或通过page_insert。确认被分配页的pp_link域为空，避免双重释放bug。当内存耗尽时返回空指针。提示：使用page2kva和memset  
```
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
		struct PageInfo *result;
	if (page_free_list == NULL)
		return NULL;

	result = page_free_list;
	page_free_list = page_free_list->pp_link;
	result->pp_link = NULL;

	if (alloc_flags & ALLOC_ZERO)
		memset(page2kva(result), 0, PGSIZE);
	return result;
}
```
page_free(struct PageInfo *pp)返回一个页到可用列表里。这个函数只有在pp_res到达0时被调用。提示：在pp_res不为0和pp_link非空时报出panic错误。
```
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	assert(pp->pp_ref == 0);
	assert(pp->pp_link == NULL);

	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```
至此，check_page_free_list(),check_page_alloc()检查通过
  
本实验，和6.828的所有实验，将要求一些推理工作来查明实际上需要什么。这个安排将不会把需要添加到JOS里代码的所有细节描述出来。查看JOS源码里需要修改的注释；那些注释通常包含具体信息和提示。  
  
## Part b 虚拟内存
在开始之前，复习x86的保护模式内存管理架构：名为分段（segmentation)和页转换（page translation)。  

> + Exercise 2
    查阅[Intel 80386 Reference Manual](https://pdos.csail.mit.edu/6.828/2018/readings/i386/toc.htm)的5，6章节。仔细阅读关于页转换和基于页的保护的部分。建议也浏览关于分段的部分；当JOS使用分页的硬件来使用虚拟内存和保护时，分段转换和基于分段的保护不能再x86上被关闭，所以需要了解它的基础。
  
### 虚拟，线性和物理地址
在x86术语中，虚拟地址包括一个分段选择器和一个段内偏移量。线性地址是在页转换前，分段转换后得到的。物理地址是在分段和页转换之后得到的地址，最终到达RAM的硬件总线。  
               Selector  +--------------+         +-----------+
              ---------->|              |         |           |
                         | Segmentation |         |  Paging   |
    Software             |              |-------->|           |---------->  RAM
                Offset   |  Mechanism   |         | Mechanism |
              ---------->|              |         |           |
                         +--------------+         +-----------+
                Virtual                   Linear                Physical  

c指针是虚拟内存中的偏移部分。在boot/boot.S中，安装了一个全局描述符表，用设置所有分段基地址到0和限制到0xffffffff来有效地关闭了分段转换。因此选择器也无效了，而线性地址永远等于虚拟地址地偏移量。在实验3中，将更多地和分段打交道来设置权限等级，但对内存转换来说，可以在整个JOS实验中忽略分段，只需要关注页转换。  
  
回想实验1的第三部分，安装了一个简单页表来让内核能够在它的链接地址（0xf0100000)上运行，实际上这个页表紧接着加载在ROM BIOS之上的物理内存（0x00100000)。这个页表仅映射了4MB的内存。在这个为JOS设置虚拟内存空间层次的过程中，将拓展这个映射到物理内存中头256MB的空间，从虚拟地址0xf0000000开始，另外还要映射虚拟地址空间的其他区域。  
  
> + Exercise 3
    在GDB只能通过虚拟地址访问QEMU的内存的情况下，有能力检查物理内存在设置虚拟内存时会很有用。复习QEMU的[监测器命令](https://pdos.csail.mit.edu/6.828/2018/labguide.html#qemu），尤其是xp指令，这个指令可以检查物理内存。为了访问QEMU监测器，在终端按下Ctrl-a c（用同样的指令回到主控制台）。

    在QEMU监测器里使用xp指令，在GDB里使用x指令来检查成对的物理和虚拟地址，确认有着同样的数据。
    实验的补丁版本QEMU提供了一个info pg指令，它展示了当前页表紧凑但细节的描述，包括所有的映射内存范围，许可和标志位。标准版QEMU也有，展示了虚拟内存映射的大概范围和许可。
  
从cpu执行代码开始，一旦在保护模式里（进入boot/boot.S时），就没方法直接使用线性或物理地址。所有的内存引用都被MMU解释为虚拟地址，意味着所有C语言指针都是虚拟地址。  
  
JOS内核通常需要以隐晦或整型的方式操作地址，而不用解引用。例如，在物理内存分配器里。有时候这些是虚拟地址，有时是物理地址。为了记录代码，JOS源码区别了这两种情况：unitptr_t类型代表隐晦虚拟地址，physaddr_t代表了物理地址。两种类型都是32位整型的重命名，所以编译器不会制止你在两个类型间赋值。因为它们都是整型而非指针，编译器在解引用它们时会报错。  
  
JOS内核可以通过转换成指针类型来解引用一个unitptr_t类型。与此相对，内核不能聪明地解引用一个物理地址，因为所有地内存引用都是通过MMU转换的。如果转换一个physaddr_t类型到指针类型并解引用，或许能够加载和存储一个返回地址（硬件将其解释为虚拟地址），但你可能不会得到你想要的内存地址。  
  
总结：  
C type	        Address type  
T*  	        Virtual  
uintptr_t  	    Virtual  
physaddr_t  	Physical  
  
> + Question 
     1.假设下列JOS内核码是正确的，变量x应该有什么类型，uintptr_t 或者 physaddr_t?
	  mystery_t x;
	  char* value = return_a_pointer();
	   *value = 10;
	  x = (mystery_t) value;
1. 上述说明可知能够正确进行类型转换的是unitptr_t

JOS内核有时需要读入去或者修改内存，在它只知道物理地址的情况下。例如，增加一个映射倒也一个页表可能需要分配物理内存来存储页目录然后初始化内存。然而内核不能通过虚拟地址转换因此不能直接加载和存储物理地址。一个JOS重新映射所有从物理地址0到虚拟地址0xf0000000的物理地址的理由是帮助内核读写内存在它只知道物理地址的情况下。为了转换物理地址到内核可以实际读写的虚拟地址，内核必须将物理地址加上0xf0000000来在重映射区域里找到对应的虚拟地址。这一步在KADDR(pa)里完成。  
  
JOS内核有时也需要能够通过给予保存内核数据结构的虚拟地址来找到一个物理地址。内核全局变量和被boot_alloc()分配的内存放在内核被加载的地方，开始于0xf0000000,也是映射所有物理地址的地方。因此，为了转换这里的一个虚拟地址到一个物理地址，内核可以简单的减去0xf0000000。这一步在PADDR(va)里实现。  
  
### 引用计数
在下面的实验里经常将同一个物理页同时映射到多个虚拟地址（或者在多环境的地址空间里）。这需要为每个物理页维护一个引用的计数，在此页对应struct PageInfo的pp_ref域里。当这个计数因为一个物理页到达0时，此页可以被释放，因为它不再被使用了。总的来说，这个计数应该等于物理页再UTOP之下所有页表里出现的次数（在UTOP之上的映射大多被内核在启动时设置了，永远都不该被释放，所以没必要引用它们）。这个计数也被用来追踪保存在页目录页里收编的指针数目，和反过来页目录对页表页的引用次数。  
  
使用page_alloc时要小心。它返回的页总是有着为0的引用计数，所以pp_ref应该尽快被增加，在你用返回页完成某些事的时候（如把它插入到页表里）。有时这一步被其他函数处理（如page_insert)，有时正在调用page_alloc的函数必须自己直接完成。  
  
### 页表管理
现在写一套方法来管理页表：插入和移除线性到物理的映射，在需要时创建页表页。  
> + Exercise 4
    在文件kern/pmap.c中，实现下列函数：
        pgdir_walk()
        boot_map_region()
        page_lookup()
        page_remove()
        page_insert()
	meminit()中调用的check_page（）测试了页表管理方法。在继续下一步前确认它能够成功报告。
  
pgdir_walk():通过传入pgdir（一个指向页目录的指针），pgdir_walk为线性地址va返回一个指向页表记录的指针。这要求在两个等级的页表结构间切换。  
相关的页表可能还没创建。在这种情况下，当creat为fales时，返回空指针。其他情况下，pgdir_walk用page_alloc分配一个新页表页。当分配失败时返回空指针；否则就增加新页的引用次数，清空页的内容，返回一个指针到新页表页里。  
提示：用page2pa()转换PagInfo到它对应的物理地址；x86的MMU在页目录和页表里都会检查许可位（低12位），所以可以安全地在页目录里可以相对保留更多的许可；在inc/mmu.h里查找有用的宏来操作页表和页目录记录。  
```
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
	assert(pgdir != NULL);
	pde_t *pg_dir_entry = NULL;
	pte_t *pg_table = NULL;
	struct PageInfo *new_page = NULL;
	
	pg_dir_entry = &pgdir[PDX(va)];
       	if (!(*pg_dir_entry & PTE_P)) {//PTE_P位记录页目录/表是否存在
		if (!create)
			return NULL;
		else {
			new_page = page_alloc(ALLOC_ZERO);
			if (new_page == NULL)
				return NULL;
			new_page->pp_ref++;
            //新页物理地址存在位，可写位，用户位置一
			*pg_dir_entry = (page2pa(new_page) | PTE_P |PTE_W | PTE_U);
		}
	}
    //PTE_ADDr返回地址所在的页目录记录再由KADDR()转换为内核虚拟地址，取得地址所在页表的地址
	pg_table = KADDR(PTE_ADDR(*pg_dir_entry));
	return &pg_table[PTX(va)];//最终返回地址所在页表页的地址。
}  
```
boot_map_region()在pgdir的页表里映射[va,va+size）的虚拟地址空间到[pa,pa+size)的物理地址空间。size为页大小的整数倍，va和pa都是页分配过的地址。  
这些记录使用许可位perm|PTE_p。  
这个函数只是用来设置UTOP之上的“静态”映射。因此它**不**应该改变被映射页的pp_ref域。  
提示：使用pgdir_walk  
```
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
	uint32_t i;
	pte_t *pg_table_entry = NULL;
	uint32_t page_num = size / PGSIZE;

	for (i = 0; i < page_num; i++) {
		pg_table_entry = pgdir_walk(pgdir, (void *) va, 1);//获取虚拟地址的页表记录
		assert(pg_table_entry != NULL);
		*pg_table_entry = pa | perm | PTE_P;//将物理地址赋给页表记录并设置许可位
		va += PGSIZE;
		pa += PGSIZE;
	}
}
```
page_lookup()返回虚拟地址va映射的页。如果pte_store非零，就把这页的pte地址存储到里面。这个函数被page_remove使用，也能被用来区别系统调用参数的页许可，但不应该被大多数的调用者使用。  
如果虚拟地址没有页映射就返回空。  
提示：使用pgdir_walk和pa2page  
```
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
	pte_t *entry = NULL;
	struct PageInfo *ret = NULL;
	
	entry = pgdir_walk(pgdir, va, 0);//尝试获取va的在页目录和表中记录的页表页地址
	if (entry == NULL)
		return NULL;
	if (!(*entry & PTE_P))
		return NULL;

	ret = pa2page(PTE_ADDR(*entry));//将页表页记录的地址转换为页地址
	if (pte_store != NULL)
		*pte_store = entry;

	return ret;
}
```
page_remove()移除物理页在虚拟地址va处的映射。  
如果va本就无物理页映射，就什么都不做。  
细节：引用计数减一；引用计数为0时释放物理页；如果PTE存在，释放va对应的页表记录；从页表中移除记录时TLB（页表缓存）一定要被无效化。  
提示：使用page_lookup,tlb_invalidate,pagedecref实现。
```
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
	pte_t *entry = NULL;
	struct PageInfo *page = page_lookup(pgdir, va, &entry);

	if (page == NULL)
		return;

	page_decref(page);//引用次数减一，为0则调用page_free()释放
	tlb_invalidate(pgdir, va);
	*entry = 0;
}
```
tlb_invalidate（）无效化一个TLB记录，除非被编辑的页表正被处理器使用。  
  
page_insert()映射物理页pp到虚拟地址va。页表记录的许可位设置为perm|PTE_P。  
要求：如果va已经映射了一个页，page_remove移除它；有必要的话，一个页表应该被分配和插入到页目录中；页的引用次数在插入成功时增加；如果va处之前存在过页则TLB必须无效化。  
边界情况提示：要考虑当同一个页被重插入到同一个虚拟地址和页目录时会发生什么。然而不要在这个代码里区分这一状况，因为这很容易引发一系列子bug；在另一个代码行里可以优雅的处理所有事。  
返回：成功时为0；无法分配页表时为-E_NO_MEM  
提示：使用pgdir_walk,pg_remove,pag2pa实现  
```
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
	pte_t *entry = NULL;
	entry = pgdir_walk(pgdir, va, 1);
	
	if (entry == NULL)
		return -E_NO_MEM;

	pp->pp_ref++;
	if(*entry & PTE_P) {
		tlb_invalidate(pgdir, va);
		page_remove(pgdir, va);
	}

	*entry = (page2pa(pp) | perm | PTE_P);

	return 0;
}
```
至此，check_page（）检查通过。  
Score: 70/70 完成。  
## Part c 内核地址空间
JOS把处理器32位线性地址空间分为两部分。用户环境（线程,将在lab3中加载和运行）,会持有对低位部分布局和内容的控制，而内核则一直保持对高位部分的完全控制。分割线被人为地定义在inc/memlayout.h中的标志ULIM，为内核保留着大约256MB的虚拟地址空间。这解释了为什么在lab1里我们需要给内核如此高的链接地址：要不然内核虚拟地址空间就不会由足够的空间来同时映射到它下面的用户环境里。  
  
在这一部分和往后的实验中查阅inc/memlayout.h中的JOS内存布局图会很有用。  
  
#### 许可和故障隔离

内核和用户内存目前都在各自的环境地址空间里，现在使用x86页表的许可位来让用户代码只能访问用户部分的地址空间。要不然会出现用户代码覆盖内核代码的bug，导致崩溃或者更更不易察觉的故障；用户代码也可能会窃取其他环境下的私有数据。注意可写位（PTE_w)影响用户和内核代码两者。  
  
用户环境将不会有任何高于ULIM内存的许可，而内核有能力读写这些内存。对[UTOP,ULIM)范围的内存，内核与用户环境有着同样的许可：它们都能读取但不能改写这些范围的的地址。这些地址被用来对用户环境暴露特定的只读内核数据结构。最后，低于UTOP的地址空间留给用户环境使用；用户环境会设置许可位来访问这些内存。  
  
### 初始化内核地址空间
现在开始设置UTOP之上的地址空间：内核部分地址空间。inc/memlayout.h展示了应该使用的布局。使用之前写的函数来设置恰当的线性到物理的映射。  
  
> + Exercise 5
    完成mem_init()中调用check_page()之后的缺失代码。
    要求代码可以通过check_kern_pgdir()和check_apg_installed_pgdir()检查。  
  
在线性地址UPAGES上映射用户只读页。  
许可：  
对于在UPAGES上的新映射-内核可读，用户可读  
页自身-内核可读写，用户无  
`boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages), PTE_U);`  
  
使用物理内存bootstack指向内核栈。内核栈从虚拟地址KSTACKTOP向下增长。可以认为[KSTACKTOP-PTSIZE, KSTACKTOP)范围都是内核栈，可以分为两段：  
[KSTACKTOP-KSTKSIZE, KSTACKTOP) -物理内存支持
[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -不支持；所以如果内核栈溢出了，它会出错而不是覆盖内存。即所谓的保护页。  
许可：内核可读写，用户无  
`boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);`  
  
映射所有物理内存到KERNBASE。  
例如虚拟地址范围[KERNBASE,2^32)应该映射到物理地址[0,2^32)的范围  
尽管可能没有2^32即KERNBASE字节的内存，但只要这么设置就好。    
许可：内核可读写，用户无  
`boot_map_region(kern_pgdir, KERNBASE, 0xffffffff - KERNBASE, 0, PTE_W);`  
  
至此，check_page_installed_pgdir(）检查通过。  
  
> + Question
     2.此刻页目录里都有哪些页表记录？它们映射了哪些地址？又指向了哪里？尽可能完成下表：  
     3.内核与用户环境放在同样的地址空间。为什么用户程序不能读写内核内存？哪些具体机制保护了内核内存？
     4.这个操作系统所能支持的最大物理内存位多少？为什么？
     5.如果真的有最大支持的物理内存，有多少空间成本来管理内存？如何分解这个成本呢？
     6.在kern/entry.s和kern/entrypgdir.c里回顾页表的设置。当页表刚启动时，EIP仍是一个低位数（略超过1MB)，在什么时候EIP会切换到在KERNBASE之上运行？从启动页表功能到在KERNBASE之上运行指令之间，什么使得继续执行低位指令变为可能？为什么这种切换很重要？
  
  
2.

| 记录  | 虚拟地址基 |  逻辑指向 |
|  ----  | ----  |-----|
| 1023|0xfff00000|物理内存最顶端4MB|
| 1022|0xffc00000|物理内存次顶端4MB|
|960|0xf0000000|物理内存头4MB|
|959|0xefc00000|内核栈与栈溢出保护页|
|957|0xef400000|当前的页表结构|
|956|0xef000000|用户只读的页表信息结构拷贝|
|2|0x00800000|？|
|1|0x00400000|？|
|0|0x00000000|见下一问|  
  
3.避免用户程序改写内核内存导致操作系统崩溃和隐患。通过分页和许可位来限制用户只读部分内核内存空间，拒绝用户访问其他内核内存。  
  
4.目前能够被页表结构管理的内存被页表信息结构存储大小限制，总的pages数组存储大小上限为一个PTSIZE＝PGSIZE * NPTENTRIES 即页目录记录所能映射的内存大小，而每个PageInfo结构大小为8字节，则能够存放4096 * 1024/8=512K个页表，故最大能够支持512 * 4096=2GB的内存空间。
  
5.最大支持物理内存时存放PageInfo信息的pages数组占据一个PTSZIE,kern_page分配了一页的内存，存放所有页地址需要512K个地址大小的空间，综合大小为4096B * 1024 + 4096B + 512 * 1024 * 4B = 6MB + 4KB。   
  
6.jmp * %eax 处跳转，之后在KERNBASE之上运行。entry_pgdir（）映射了虚拟地址[0, 4MB) 到物理地址的 [0, 4MB)，使得低位指令执行仍可用。否则将无法使用低位命令启动内核。
  
> + challenge 
    目前花费了许多物理页空间来为内核映射支持页表。可以采用一个更空间效率的用法，使用PTE_PS（Page szie)位。这个标志位在原版的80386中不支持，但在更现代的x86处理器里支持。查阅[Intel manuals](https://pdos.csail.mit.edu/6.828/2018/readings/ia32/IA32-3A.pdf)第三卷。确保设计的内核只在支持它的处理器上使用这一优化。
  
PSE标志位在CR4的第四位控制启用。  
PSE标志位使能了大页尺寸：4MB字节页或2MB字节页（在设置了PAE物理地址扩展位时）。当PSE位空时，使用通常的4KB大小页。  
4MB页的线性地址转换：![大页地址转换](https://user-images.githubusercontent.com/75117698/114344311-2a2c2a00-9b92-11eb-971d-dc1eb25908eb.png)
  
### 其他地址空间布局
JOS使用的地址空间布局只是可能的的一个。一个操作系统可以映射内核到低位线性地址而把高位线性地址空间留给用户进程。x86内核总体上不采用这个路线，然而，因为x86的一个前向兼容模式，虚拟8086模式，时硬件绑定在处理器里使用底部的线性空间，这导致当内核映射在这里时将完全无法使用这一模式。  
  
尽管难得多，仍然可能设计这样一个内核，不必为自己保留任何固定的处理器线性或虚拟地址空间，而能够允许用户等级进程有效地无限制使用整个4GB虚拟地址空间，同时依旧完全地从这些进程中保护内核，并在不同地进程间保护各自进程。  
    
  
